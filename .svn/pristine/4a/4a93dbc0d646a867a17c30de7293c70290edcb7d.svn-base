/**
 * Created by haoqianhuang on 2017/12/29.
 */
//import numbers from 'numbers'
var tableData = [];//要显示的表
/*接下来的数组是后面评估页面需要用到的数据*/
var deltatuArr = [];
var quArr = [];
var qgArr = [];
var pArr = [];
var tLArr = [];
var tHArr = [];
var copcArr = [];
var EERArr = [];
var WTEuArr = [];
var WTEgArr = [];
var betaArr = [];

const calculate = {

	//输入：读取excel表并转化为对象数组的data，季节，输出显示的tableData，包括tgo, tg, a, n, cop, eer
	//位置：addProject
	getTableData: (data,season) =>{
		let self = calculate;
		var season = season;
		for(let i = 0;i<data.length;i++){
			//用户侧温差
			let deltatu = Math.abs(data[i].tui-data[i].tuo);

			//用户侧换热量
			let qu = self._getqu(data,i);

			//地源侧温差
			let deltatg = self._getDeltatg();

			//地源侧换热量
			let qg = 1/3600*1000*4.18*deltatg*data[i].gg;

			//总能耗
			let p = self._getp(data,i);

			//机组能效cop
			let cop = self._getcop(data,i) ;

			let tL = self._gettL(data,season,i);
			let tH = self._gettH(data,season,i);
			//卡诺循环能效copc
			let copc = self._getcopc(data,season,i);

			//系统能效EER:
			let EER = self._getEER(data,i);

			//水输送效率:
			let WTEu = self._getWTEu(data,i);

			let WTEg = qu/data[i].pg;
			let beta = self._getBeta(data.i);

			//alpha
			let alpha = data[i].pl/p;

			//eta
			let eta = self._getEta(data,i,season);

			//特征值表子元素
			let obj = {};
			obj.tgo = data[i].tgo;
			obj.deltatg = deltatg;
			obj.alpha = alpha;
			obj.eta = eta;
			obj.cop = cop;
			obj.EER = EER;

			//其他不显示的数据
			deltatuArr.push(deltatu);
			quArr.push(qu);
			qgArr.push(qg);
			pArr.push(p);
			tLArr.push(tL);
			tHArr.push(tH);
			copcArr.push(copc);
			EERArr.push(EER);
			WTEuArr.push(WTEu);
			WTEgArr.push(WTEg);
			betaArr.push(beta);

			tableData.push(obj);
		}
		return tableData;
	},

	/*贾坤那边每次重新排序后调用,arr为当前改版的一列*/
	afterSort:(tableData,arr,season)=>{
		let data = [];
		tableData[length-1] = arr;
		tableData = numbers.matrix.rotate(tableData, 90, counterclockwise);
		tableData = numbers.matrix.reverseRows(tableData);
		let keys = ['tgo','deltatg','alpha','eta','cop','EER'];
		tableData.push(keys);
		for(let i = 0;i<tableData.length;i++){
			for(let j = 0;j<tableData[i].length;j++){
				let key = tableData[length-1][j];
				data[key] = tableData[i][j];
			}
		}
		self.dataList = data;
		console.log(data);
		let EERArr = calculate._getDeltaEER(dataList,season);
		return EERArr;
	},

	_getDeltatg:(data,index)=>{
		return  Math.abs(data[index].tgi-data[index].tgo);
	},

	_getqu:(data,index)=>{
		let deltatu = Math.abs(data[index].tui-data[index].tuo);
		return 1/3600*1000*4.18*deltatu*data[index].gu;
	},

	_getcop:(data,index)=>{
		let qu = calculate._getqu(data,index);
		return data[index].qu/data[index].pl;
	},

	_getcopc:(data,season,index)=>{
		let tL = calculate._gettL(data,season,index);
		let tH = calculate._gettH(data,season,index);
		return (season == summer) ? tL/(tH - tL) : tH/(tH - tL);
	},

	_getp:(data,index)=>{
		return data[index].pl + data[index].pg + data[index].pu;
	},

	//tL存入数组tLs
	_gettL:(data,season,index) => {
		let tL = (season == summer)?(data[index].tui+data[index].tuo)/2-5 : (data[index].tgi+data[index].tgo)/2-5;
		return tL;
	},

	//将tH存入数组tHs
	_gettH:(data,season,index) => {
		let tH = (season == summer)?(data[index].tgi+data[index].tgo)/2+5 : (data[index].tui+data[index].tuo)/2+5;
		return tH;
	},

	_getEER:(data,index)=>{
		let qu = calculate._getqu(data,index);
		let p = calculate._getp(data,index);
		return  qu/p;
	},

	_getWTEu:(data,index)=>{
		let qu = calculate._getqu(data,index);
		return qu/data[index].pu;
	},


	_getBeta:(data,index)=>{
		let qu = calculate._getqu(data,index);
		return qu/(data[index].pu + data[index].pg);
	},

	_getEta:(data,index,season)=>{
		let cop = calculate._getcop(data,index) ;
		let copc = calculate._getcopc(data,season,index);
		return cop/copc;
	},



	/*权重部分*/
	_getWtEERt:(data,pos,season)=>{
		let self = calculate;
		let key = ['eta','deltatg','tgo'];
		let EtaArr = self._getArr(data,key[0]);
		let _Eta = self._getAvg(EtaArr);

		let deltatgArr = self._getArr(data,key[1]);
		let _deltatg = self._getAvg(deltatgArr);

		//let tLArr = this._gettLArr(data,season);
		let _tL = self._getAvg(tLArr);

		//let betaArr = this._getBetaArr(data);
		let _beta = self._getAvg(betaArr);

		//let tHArr = this._gettHArr(data,season);
		let _tH = self._getAvg(tHArr);

		let tgoArr = self._getArr(data,key[2]);

		let tgoVal = self._getQuar(tgoArr,pos);
		if(season == summer){
			return [1/(1/_Eta*(tgoVal + 0.5*_deltatg + 5 -_tL)/(_tL + 273.15) + 1/_beta),tgoVal];
		}
		else if(season == winter){
			return [1/(1/_Eta*(_tH - (tgoVal - 0.5*_deltatg - 5)/(_tL + 273.15) + 1/_beta)),tgoVal];
		}
		else{
			this.$message({
				message: '文件格式不对',
				type: 'warning'
			});
		}
	},

	_getWDeltaEER:(data,pos)=>{
		let self = calculate;
		//let copArr = this._getcopArr(data);
		let _cop = self._getAvg(copArr);

		//let WTEArr = this._getWTEArr(data);
		let _WTE = self._getAvg(WTEArr);

		//let EERArr = this._getEERArr(data);
		let _EER = self._getAvg(EER);

		let deltatgArr = self._getArr(data,'deltatg');
		let _deltatg = self._getAvg(deltatgArr);

		let tgVal = self._getQuar(deltatgArr,pos);
		return [1/(1/_cop + 1/_WTE + _deltatg/tgVal*(1/_EER-1/_cop-1/_WTE)),tgVal];
	},

	_getWEtaEQuar:(data,pos,season)=>{
		let self = calculate;
		let copArr = this._getArr(data,'cop');
		let _cop = self._getAvg(copArr);

		//let betaArr = this._getBetaArr(data);
		let _beta = self._getAvg(betaArr);

		let EtaArr = self._getArr(data,'eta',season);
		let etaVal = self._getQuar(EtaArr,pos);
		return [1/(1/(etaVal*_cop) + 1/_beta),etaVal];
	},

	_getWAlphaEER:(data,pos)=>{
		let self = calculate;
		let EtaArr = self._getArr(data,'eta');
		let _Eta = self._getAvg(EtaArr);

		let copArr = this._getArr(data,'cop');
		let _cop = self._getAvg(copArr);

		let alphaArr = self._getArr(data,'alpha');
		let alphaVal = self._getQuar(alphaArr,pos);
		return [alphaVal*_Eta*_cop,alphaVal];
	},

	_getW:(data,type,season)=>{
		let self = calculate;
		let EERslt1;
		let EERslt2;

		let deltatgArr = self._getArr(data,'deltatg');
		let EtaArr = self._getArr(data,'eta');
		let alphaArr = self._getArr(data,'alpha');

		switch(type)
		{
			case 't':
				EERslt1 = self._getWtEERt(data,1,season);
				EERslt2 = self._getWtEERt(data,3,season);
				break;
			case 'delta':
				EERslt1 = self._getWDeltaEER(deltatgArr,1);
				EERslt2 = self._getWDeltaEER(deltatgArr,3);
				break;
			case 'eta':
				EERslt1 = self._getWEtaEQuar(EtaArr,1);
				EERslt2 = self._getWEtaEQuar(EtaArr,3);
				break;
			case 'alpha':
				EERslt1 = self._getWAlphaEER(alphaArr,1);
				EERslt2 = self._getWAlphaEER(alphaArr,3);
				break;
			default:
				alert("参数错误");
				break;
		}

		let _EER1 = EERslt1[0];
		let _EER2 = EERslt2[0];
		let _denom1 = EERslt1[1];
		let _denom2 = EERslt2[1];

		return (_EER1 - _EER2)/(_denom1 - _denom2);
	},

	_getWVector:(data,season)=>{
		let self = calculate;
		let Wt = self._getW(data,'t',season);
		let Wdelta = self._getW(data,'delta',season);
		let Weta = self._getW(data,'eta',season);
		let Walpha = self._getW(data,'alpha',season);
		let arr = [];
		arr.push(Wt,Wdelta,Weta,Walpha);
		console.log('arr' + arr);
		return arr;
	},

	_getX:(table)=>{
		let A = [];
		let Ao = [0, 0, 0, 0];
		let n = table.length;
		console.log(n);
		//将字符串前后空格去掉，解析为浮点数
		for (let row of table) {
			row.tgo = parseFloat(row.tgo);
			row.tg = parseFloat(row.tg);
			row.a = parseFloat(row.a);
			row.n = parseFloat(row.n);
			row.cop = parseFloat(row.cop);
			row.eer = parseFloat(row.eer);
		}
		//存为二维数组
		for (let row of table) {

			let temp = [];
			temp.push(row.tgo);
			temp.push(row.tg);
			temp.push(row.a);
			temp.push(row.n);
			A.push(temp);
		}

		//获得均值
		for (let row of table) {
			Ao[0] += row.tgo;
			Ao[1] += row.tg;
			Ao[2] += row.a;
			Ao[3] += row.n;
		}
		Ao = Ao.map((item) => item/n);
		console.log(Ao);

		//获得偏差矩阵
		console.log(222,A);
		console.log('Ao: ' + Ao);
		for (let i = 0; i < n; i++) {
			A[i] = numbers.matrix.subtraction(A[i], Ao);
		}

		console.log(3333,A);
		return A;
	},

	_getF:(X,_vector)=>{
		return numbers.matrix.multiply(X[i], _vector);
	},

	/*最终结果*/
	_getDeltaEER:(data,season)=>{
		let self = calculate;
		let _vector = self._getWVector(data,season);
		let X = self._getX(data);
		let F = self._getF(X,_vector);
		let DeltaEER = [];
		for(let i of F){
			for(let j of F[i]){
				DeltaEER[i] += F[i][j];
			}
		}
		return DeltaEER;
	},

	_getArr:(data,key)=>{
		let Arr = [];
		for(let item of data){
			Arr.push(item[key])
		}
		return Arr;
	},
	/*先存进数组，再求平均数*/
	/*_getEtaArr:(tableData)=>{
		let EtaArr = [];
		for(let i = 0;i<tableData.length;i++){
			EtaArr.push(tableData[i].eta);
		}
		return EtaArr;
	},

	_getDeltatgArr:(data)=>{

		let deltatgArr = [];
		for(let i = 0;i<data.length;i++){
			deltatgArr.push(_getDeltatg(data,i));
		}
		return deltatgArr;
	},

	_gettLArr:(data,season)=>{
		let tLArr = [];
		for(let i = 0;i<data.length;i++){
			tLArr.push(_gettL(data,season,i));
		}
		return tLArr;
	},

	_getBetaArr:(data)=>{
		let betaArr = [];
		for(let i = 0;i<data.length;i++){
			betaArr.push(_getBeta(data,i));
		}
		return betaArr;
	},

	_gettHArr:(data,season)=>{
		let tHArr = [];
		for(let i = 0;i<data.length;i++){
			tHArr.push(_gettH(data,season,i));
		}
		return tHArr;
	},

	_gettgoArr:(data)=>{
		let tgoArr = [];
		for(let i = 0;i<data.length;i++){
			tgoArr.push(data[i].tgo);
		}
		return tgoArr;
	},

	_getcopArr:(tableData)=>{
		let copArr = [];
		for(let i = 0;i<tableData.length;i++){
			copArr.push(tableData[i].cop);
		}
		return copArr;
	},

	_getWTEArr:(data)=>{
		let WTEArr = [];
		for(let i = 0;i<data.length;i++){
			WTEArr.push(_getWTEu(data,i));
		}
		return WTEArr;
	},

	_getEERArr:(data)=>{
		let EERArr = [];
		for(let i = 0;i<data.length;i++){
			EERArr.push(_getEER(data,i));
		}
		return EERArr;
	},

	_getAlphaArr:(tableData)=>{
		let AlphaArr = [];
		for(let i = 0;i<tableData.length;i++){
			AlphaArr.push(tableData[i].alpha);
		}
		return AlphaArr;
	},*/




	_getAvg:(data)=>{
		let avg = 0;
		for(let i = 0; i < data.length;i++){
			avg += data[i].index;
		}
		avg = avg/data.length;
		return avg ;
	},



	//计算四分位数,输入：数组和上/下分位，index为1或者3
	_getQuar: (arr, index) => {
		var self = calculate;
		let quartile;
		let sortedArr = self._sortArr(arr);
		let num = (sortedArr.length + 1) / 4 * index;
		let integer = parseInt(num);
		//分为整数和小数两种情况
		if (integer === num) {
			quartile = sortedArr[num - 1];
		}
		else {
			quartile = sortedArr[integer - 1] * 0.25 + sortedArr[integer] * 0.75;
		}
		console.log('quartile ' + quartile);
		return quartile;
	},

	_sortArr: (arr) => {
		return arr.sort(function (a, b) {
			return a - b;
		});
	}
}
export default  calculate